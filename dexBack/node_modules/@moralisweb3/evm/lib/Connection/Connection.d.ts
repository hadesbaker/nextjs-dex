import { providers } from 'ethers';
import TypedEmitter from 'typed-emitter';
import { EvmAddress, EvmChain, EvmConnect, LoggerController } from '@moralisweb3/core';
import { EvmAbstractConnector } from '@moralisweb3/evm-connector-utils';
import { EvmNetworkEventMap } from '../events/EvmNetworkEvent';
import { Connectors } from './Connectors';
export declare class Connection {
    private _logger;
    private _emitter;
    readonly connectors: Connectors;
    private _internalProvider;
    private _provider;
    connector: EvmAbstractConnector | null;
    private readonly state;
    constructor(logger: LoggerController, emitter: TypedEmitter<EvmNetworkEventMap>);
    private _handleAccountChange;
    private _handleChainChange;
    /**
     * Updates the ._provider (and therefore .provider) instance, based on the
     * _internalProvider, that is retreived from a connector, and the provided chain.
     * We need to reset this provider every time a chain chainges, as recommended by ethersJs,
     * for user protection.
     */
    private _updateProvider;
    /**
     * State change handlers
     */
    private handleDisconnected;
    /**
     * Connect to the Evm chain vased on the provided wallet and its options.
     * Will trigger a CONNECT_SUCCESS event on success or CONNECT_ERROR event on error
     */
    private handleConnecting;
    private handleConnected;
    /**
     * Utilities
     */
    get isConnected(): boolean;
    get isConnecting(): boolean;
    get canConnect(): boolean;
    /**
     * Trigger state changes
     */
    connect: EvmConnect;
    disconnect: () => Promise<void>;
    cancelRequest: () => Promise<void>;
    /**
     * Getters
     */
    get hasProvider(): boolean;
    get provider(): providers.JsonRpcSigner | null;
    get chain(): EvmChain | null;
    get account(): EvmAddress | null;
}
//# sourceMappingURL=Connection.d.ts.map