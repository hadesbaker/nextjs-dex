'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ethers = require('ethers');
var core = require('@moralisweb3/core');
var evmConnectorUtils = require('@moralisweb3/evm-connector-utils');
var MetamaskConnector = require('@moralisweb3/evm-metamask-connector');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var MetamaskConnector__default = /*#__PURE__*/_interopDefaultLegacy(MetamaskConnector);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

/**
 * Events fired by MoralisEvm upon changes in the network status
 */
var EvmNetworkEvent;
(function (EvmNetworkEvent) {
    // Fired when a valid connect to a network has been established
    EvmNetworkEvent["CONNECTING"] = "Connecting";
    EvmNetworkEvent["CONNECTED"] = "Connected";
    EvmNetworkEvent["DISCONNECTED"] = "Disconnected";
    EvmNetworkEvent["CONNECTING_ERROR"] = "ConnectingError";
    EvmNetworkEvent["CHAIN_CHANGED"] = "ChainChanged";
    EvmNetworkEvent["ACCOUNT_CHANGED"] = "AccountChanged";
    EvmNetworkEvent["PROVIDER_UPDATED"] = "ProviderUpdated";
})(EvmNetworkEvent || (EvmNetworkEvent = {}));

var isValidChain = function (chain) {
    if (chain instanceof core.EvmChain) {
        return true;
    }
    return false;
};
var assertChain = function (chain, message) {
    if (!isValidChain(chain)) {
        throw new core.MoralisNetworkError({
            code: core.NetworkErrorCode.NO_CHAIN_SET,
            message: message !== null && message !== void 0 ? message : 'No valid chain',
        });
    }
    return chain;
};
/**
 * @param {EvmChain} providedChain The chain provided from function call.
 * @param {EvmChain} chain The evm chain.
 */
var assertChainEquality = function (providedChain, chain) {
    if (!chain.equals(providedChain)) {
        throw new core.MoralisNetworkError({
            code: core.NetworkErrorCode.CHAIN_MISMATCH,
            message: "Expected chain ".concat(chain.apiHex, ", but got ").concat(core.EvmChain.create(providedChain).apiHex),
        });
    }
};

var isValidProvider = function (provider) {
    if (provider instanceof ethers.ethers.providers.JsonRpcSigner) {
        return true;
    }
    return false;
};
var assertProvider = function (provider, message) {
    if (!isValidProvider(provider)) {
        throw new core.MoralisNetworkError({
            code: core.NetworkErrorCode.NO_CHAIN_SET,
            message: message !== null && message !== void 0 ? message : 'Provider is not set. Make sure to have called Moralis.connect() or MoralisEvm.connect() first',
        });
    }
    return provider;
};

var ethTxReceiptToMoralisTxReceipt = function (_a) {
    var effectiveGasPrice = _a.effectiveGasPrice, tx = __rest(_a, ["effectiveGasPrice"]);
    return (__assign(__assign({}, tx), { gasPrice: effectiveGasPrice }));
};
var ethTxResponseToMoralisTxResponse = function (_a, chain) {
    var chainId = _a.chainId, tx = __rest(_a, ["chainId"]);
    return (__assign(__assign({}, tx), { 
        // Manually overwrite chain, because EthersJs does not set it correctly
        chain: chain !== null && chain !== void 0 ? chain : chainId }));
};
var waitForResponse = function (ethResult, transaction, confirmations) { return __awaiter(void 0, void 0, void 0, function () {
    var receipt;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, ethResult.wait(confirmations)];
            case 1:
                receipt = _a.sent();
                return [2 /*return*/, new core.EvmTransactionReceipt(ethTxReceiptToMoralisTxReceipt(receipt), transaction)];
        }
    });
}); };
var wrapEthersTransactionResponse = function (ethersTransactionResponse, chainId) {
    return core.EvmTransactionResponse.create(ethTxResponseToMoralisTxResponse(ethersTransactionResponse, chainId), function (transactionResponse, confirmations) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
        return [2 /*return*/, waitForResponse(ethersTransactionResponse, transactionResponse, confirmations)];
    }); }); });
};

var makeSendTransaction = function (_provider, _chain) { return function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var provider, chain, transaction;
    var _a;
    return __generator(this, function (_b) {
        provider = assertProvider(_provider);
        chain = assertChain((_a = data.chain) !== null && _a !== void 0 ? _a : _chain, 'Chain is not set on MoralisEvm. Make sure to be properly connected');
        data.chain = chain;
        transaction = core.EvmTransaction.create(data, function (tx) { return __awaiter(void 0, void 0, void 0, function () {
            var ethTransactionResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, provider.sendTransaction(tx.toEthRequest())];
                    case 1:
                        ethTransactionResponse = _a.sent();
                        return [2 /*return*/, wrapEthersTransactionResponse(ethTransactionResponse, chain)];
                }
            });
        }); });
        return [2 /*return*/, transaction.send()];
    });
}); }; };

var makeSignMessage = function (_provider) { return function (message) { return __awaiter(void 0, void 0, void 0, function () {
    var provider, signature;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                provider = assertProvider(_provider);
                return [4 /*yield*/, provider.signMessage(message)];
            case 1:
                signature = _a.sent();
                return [2 /*return*/, signature];
        }
    });
}); }; };

var makeTransferNative = function (sendTransaction, _chain) {
    return function (options) { return __awaiter(void 0, void 0, void 0, function () {
        var to, value, chain, transaction;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    to = core.EvmAddress.create(options.to);
                    value = core.EvmNative.create(options.value);
                    chain = assertChain(_chain, 'Chain is not set on MoralisEvm. Make sure to be properly connected');
                    if (options.chain) {
                        assertChainEquality(options.chain, chain);
                    }
                    return [4 /*yield*/, sendTransaction({
                            to: to.checksum,
                            value: value.value,
                            chain: chain,
                        })];
                case 1:
                    transaction = _a.sent();
                    return [2 /*return*/, transaction];
            }
        });
    }); };
};

/* Autogenerated file. Do not edit manually. */
var _abi$2 = [
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
            {
                name: "_id",
                type: "uint256",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_ids",
                type: "uint256[]",
            },
            {
                name: "_values",
                type: "uint256[]",
            },
            {
                name: "_data",
                type: "bytes",
            },
        ],
        name: "safeBatchTransferFrom",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owners",
                type: "address[]",
            },
            {
                name: "_ids",
                type: "uint256[]",
            },
        ],
        name: "balanceOfBatch",
        outputs: [
            {
                name: "",
                type: "uint256[]",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_operator",
                type: "address",
            },
            {
                name: "_approved",
                type: "bool",
            },
        ],
        name: "setApprovalForAll",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
            {
                name: "_operator",
                type: "address",
            },
        ],
        name: "isApprovedForAll",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_id",
                type: "uint256",
            },
            {
                name: "_value",
                type: "uint256",
            },
            {
                name: "_data",
                type: "bytes",
            },
        ],
        name: "safeTransferFrom",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "_operator",
                type: "address",
            },
            {
                indexed: true,
                name: "_from",
                type: "address",
            },
            {
                indexed: true,
                name: "_to",
                type: "address",
            },
            {
                indexed: false,
                name: "_id",
                type: "uint256",
            },
            {
                indexed: false,
                name: "_value",
                type: "uint256",
            },
        ],
        name: "TransferSingle",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "_operator",
                type: "address",
            },
            {
                indexed: true,
                name: "_from",
                type: "address",
            },
            {
                indexed: true,
                name: "_to",
                type: "address",
            },
            {
                indexed: false,
                name: "_ids",
                type: "uint256[]",
            },
            {
                indexed: false,
                name: "_values",
                type: "uint256[]",
            },
        ],
        name: "TransferBatch",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "_owner",
                type: "address",
            },
            {
                indexed: true,
                name: "_operator",
                type: "address",
            },
            {
                indexed: false,
                name: "_approved",
                type: "bool",
            },
        ],
        name: "ApprovalForAll",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                name: "_value",
                type: "string",
            },
            {
                indexed: true,
                name: "_id",
                type: "uint256",
            },
        ],
        name: "URI",
        type: "event",
    },
];
var Erc1155__factory = /** @class */ (function () {
    function Erc1155__factory() {
    }
    Erc1155__factory.createInterface = function () {
        return new ethers.utils.Interface(_abi$2);
    };
    Erc1155__factory.connect = function (address, signerOrProvider) {
        return new ethers.Contract(address, _abi$2, signerOrProvider);
    };
    Erc1155__factory.abi = _abi$2;
    return Erc1155__factory;
}());

/* Autogenerated file. Do not edit manually. */
var _abi$1 = [
    {
        constant: true,
        inputs: [],
        name: "name",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_spender",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "decimals",
        outputs: [
            {
                name: "",
                type: "uint8",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "balance",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [],
        name: "symbol",
        outputs: [
            {
                name: "",
                type: "string",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_value",
                type: "uint256",
            },
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
            {
                name: "_spender",
                type: "address",
            },
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        payable: true,
        stateMutability: "payable",
        type: "fallback",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                name: "spender",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Approval",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address",
            },
            {
                indexed: true,
                name: "to",
                type: "address",
            },
            {
                indexed: false,
                name: "value",
                type: "uint256",
            },
        ],
        name: "Transfer",
        type: "event",
    },
];
var Erc20__factory = /** @class */ (function () {
    function Erc20__factory() {
    }
    Erc20__factory.createInterface = function () {
        return new ethers.utils.Interface(_abi$1);
    };
    Erc20__factory.connect = function (address, signerOrProvider) {
        return new ethers.Contract(address, _abi$1, signerOrProvider);
    };
    Erc20__factory.abi = _abi$1;
    return Erc20__factory;
}());

/* Autogenerated file. Do not edit manually. */
var _abi = [
    {
        constant: true,
        inputs: [
            {
                name: "_tokenId",
                type: "uint256",
            },
        ],
        name: "getApproved",
        outputs: [
            {
                name: "",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_approved",
                type: "address",
            },
            {
                name: "_tokenId",
                type: "uint256",
            },
        ],
        name: "approve",
        outputs: [],
        payable: true,
        stateMutability: "payable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_tokenId",
                type: "uint256",
            },
        ],
        name: "transferFrom",
        outputs: [],
        payable: true,
        stateMutability: "payable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_tokenId",
                type: "uint256",
            },
        ],
        name: "safeTransferFrom",
        outputs: [],
        payable: true,
        stateMutability: "payable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_tokenId",
                type: "uint256",
            },
        ],
        name: "ownerOf",
        outputs: [
            {
                name: "",
                type: "address",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "",
                type: "uint256",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_operator",
                type: "address",
            },
            {
                name: "_approved",
                type: "bool",
            },
        ],
        name: "setApprovalForAll",
        outputs: [],
        payable: false,
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        constant: false,
        inputs: [
            {
                name: "_from",
                type: "address",
            },
            {
                name: "_to",
                type: "address",
            },
            {
                name: "_tokenId",
                type: "uint256",
            },
            {
                name: "data",
                type: "bytes",
            },
        ],
        name: "safeTransferFrom",
        outputs: [],
        payable: true,
        stateMutability: "payable",
        type: "function",
    },
    {
        constant: true,
        inputs: [
            {
                name: "_owner",
                type: "address",
            },
            {
                name: "_operator",
                type: "address",
            },
        ],
        name: "isApprovedForAll",
        outputs: [
            {
                name: "",
                type: "bool",
            },
        ],
        payable: false,
        stateMutability: "view",
        type: "function",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "_from",
                type: "address",
            },
            {
                indexed: true,
                name: "_to",
                type: "address",
            },
            {
                indexed: true,
                name: "_tokenId",
                type: "uint256",
            },
        ],
        name: "Transfer",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "_owner",
                type: "address",
            },
            {
                indexed: true,
                name: "_approved",
                type: "address",
            },
            {
                indexed: true,
                name: "_tokenId",
                type: "uint256",
            },
        ],
        name: "Approval",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "_owner",
                type: "address",
            },
            {
                indexed: true,
                name: "_operator",
                type: "address",
            },
            {
                indexed: false,
                name: "_approved",
                type: "bool",
            },
        ],
        name: "ApprovalForAll",
        type: "event",
    },
];
var Erc721__factory = /** @class */ (function () {
    function Erc721__factory() {
    }
    Erc721__factory.createInterface = function () {
        return new ethers.utils.Interface(_abi);
    };
    Erc721__factory.connect = function (address, signerOrProvider) {
        return new ethers.Contract(address, _abi, signerOrProvider);
    };
    Erc721__factory.abi = _abi;
    return Erc721__factory;
}());

/* Autogenerated file. Do not edit manually. */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Erc1155__factory: Erc1155__factory,
    Erc20__factory: Erc20__factory,
    Erc721__factory: Erc721__factory
});

var makeTransferErc20 = function (_provider, _chain) {
    return function (options) { return __awaiter(void 0, void 0, void 0, function () {
        var provider, chain, contractAddress, toAddress, value, token, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    provider = assertProvider(_provider);
                    chain = assertChain(_chain, 'Chain is not set on MoralisEvm. Make sure to be properly connected');
                    if (options.chain) {
                        assertChainEquality(options.chain, chain);
                    }
                    contractAddress = core.EvmAddress.create(options.contractAddress);
                    toAddress = core.EvmAddress.create(options.to);
                    value = core.Erc20Value.create(options.value).value;
                    token = Erc20__factory.connect(contractAddress.checksum, provider);
                    return [4 /*yield*/, token.transfer(toAddress.checksum, value)];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, wrapEthersTransactionResponse(response, _chain)];
            }
        });
    }); };
};

var isValidAddress = function (address) {
    if (address instanceof core.EvmAddress) {
        return true;
    }
    return false;
};
var assertAddress = function (address, message) {
    if (!isValidAddress(address)) {
        throw new core.MoralisNetworkError({
            code: core.NetworkErrorCode.NO_CHAIN_SET,
            message: message !== null && message !== void 0 ? message : 'No valid address',
        });
    }
    return address;
};

var makeTransferErc721 = function (_provider, _account, _chain) {
    return function (options) { return __awaiter(void 0, void 0, void 0, function () {
        var provider, fromAddress, chain, contractAddress, toAddress, tokenId, token, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    provider = assertProvider(_provider);
                    fromAddress = assertAddress(_account, 'No account is connected');
                    chain = assertChain(_chain, 'Chain is not set on MoralisEvm. Make sure to be properly connected');
                    if (options.chain) {
                        assertChainEquality(options.chain, chain);
                    }
                    contractAddress = core.EvmAddress.create(options.contractAddress);
                    toAddress = core.EvmAddress.create(options.to);
                    tokenId = options.tokenId;
                    token = Erc721__factory.connect(contractAddress.checksum, provider);
                    return [4 /*yield*/, token['safeTransferFrom(address,address,uint256)'](fromAddress.checksum, toAddress.checksum, tokenId)];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, wrapEthersTransactionResponse(response, chain)];
            }
        });
    }); };
};

var connectWallet = function (connectors, connectorName, options) { return __awaiter(void 0, void 0, void 0, function () {
    var connector, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                connector = connectors.get(connectorName);
                return [4 /*yield*/, connector.connect(options)];
            case 1:
                data = _a.sent();
                return [2 /*return*/, __assign(__assign({}, data), { connector: connector })];
        }
    });
}); };
var cancelWalletRequest = function (connector) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, connector.cancelRequest()];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };

var DEFAULT_CONNECTORS = [MetamaskConnector__default["default"]];
var Connectors = /** @class */ (function () {
    function Connectors(core$1) {
        var _this = this;
        this.core = core$1;
        this._connectors = new Map();
        /**
         * Register a new connector based on a EvmAbstractConnector
         */
        this.register = function (connector) {
            if ('create' in connector) {
                connector = connector.create(_this.core);
            }
            if (_this._connectors.has(connector.name)) {
                throw new core.MoralisNetworkError({
                    code: core.NetworkErrorCode.DUPLICATE_WALLET,
                    message: "The connector ".concat(connector.name, " has already been registered."),
                });
            }
            _this._connectors.set(connector.name, connector);
        };
        /**
         * Returns the connector with the given name.
         * This connector should have been registered with `register`
         * Throws an error if no connector with the given name has been registered.
         */
        this.get = function (name) {
            var module = _this._connectors.get(name);
            if (!module) {
                throw new core.MoralisNetworkError({
                    code: core.NetworkErrorCode.WALLET_NOT_FOUND,
                    message: "Connector \"".concat(name, "\" does not exist."),
                });
            }
            return module;
        };
        /**
         * Remove the connector with the provided name, if it has been registered,
         * or throws an error if the connector cannot be found.
         */
        this.remove = function (name) {
            var isRemoved = _this._connectors.delete(name);
            if (!isRemoved) {
                throw new core.MoralisNetworkError({
                    code: core.NetworkErrorCode.WALLET_NOT_FOUND,
                    message: "Connector \"".concat(name, "\" does not exist."),
                });
            }
        };
        /**
         * List all the registered connectors
         */
        this.list = function () {
            return Array.from(_this._connectors.values());
        };
    }
    Connectors.create = function () {
        var core$1 = core.MoralisCoreProvider.getDefault(); // TODO: we should get the core instance from a parent class.
        var connectors = new Connectors(core$1);
        DEFAULT_CONNECTORS.forEach(function (connector) { return connectors.register(connector); });
        return connectors;
    };
    Object.defineProperty(Connectors.prototype, "names", {
        /**
         * Returns the names of all registered connectors
         */
        get: function () {
            return this.list().map(function (module) { return module.name; });
        },
        enumerable: false,
        configurable: true
    });
    return Connectors;
}());

var Connection = /** @class */ (function () {
    function Connection(logger, emitter) {
        var _this = this;
        // Provider that is returned from a connection to a connector (is used to establish the provider via _updateProvider())
        this._internalProvider = null;
        // EthersJs provider, used to make chain interactions
        this._provider = null;
        // Used connector for the currect connection
        this.connector = null;
        this.state = new core.MoralisState('Connection');
        this._handleAccountChange = function (account) {
            _this._logger.verbose('Chain changed', { account: account });
            _this._emitter.emit(EvmNetworkEvent.ACCOUNT_CHANGED, { account: account });
        };
        this._handleChainChange = function (chain) {
            _this._logger.verbose('Chain changed', { chain: chain });
            _this._emitter.emit(EvmNetworkEvent.CHAIN_CHANGED, { chain: chain });
            _this._updateProvider();
        };
        /**
         * State change handlers
         */
        this.handleDisconnected = function (context, event) {
            if (event.type === 'xstate.init') {
                // Don't do anything initially, as we start in disconnected state
                return;
            }
            _this._internalProvider = null;
            _this._updateProvider();
            if (_this.connector) {
                _this.connector.off(evmConnectorUtils.EvmConnectorEvent.ACCOUNT_CHANGED, _this._handleAccountChange);
                _this.connector.off(evmConnectorUtils.EvmConnectorEvent.CHAIN_CHANGED, _this._handleChainChange);
                _this.connector = null;
            }
            _this._logger.verbose('Disconnected', { context: context, event: event });
            _this._emitter.emit(EvmNetworkEvent.DISCONNECTED);
            if (event.type === 'CONNECT_ERROR') {
                var error = event.data;
                _this._emitter.emit(EvmNetworkEvent.CONNECTING_ERROR, error);
                throw new core.MoralisNetworkError({
                    code: core.NetworkErrorCode.CANNOT_CONNECT,
                    message: "Connection failed: ".concat(error.name, ": ").concat(error.message),
                    cause: error,
                });
            }
        };
        /**
         * Connect to the Evm chain vased on the provided wallet and its options.
         * Will trigger a CONNECT_SUCCESS event on success or CONNECT_ERROR event on error
         */
        this.handleConnecting = function (context, event) {
            _this._logger.verbose('Connecting', { context: context, event: event });
            // Should only call connecting via the CONNECT event
            if (event.type !== 'CONNECT') {
                throw new core.MoralisNetworkError({
                    code: core.NetworkErrorCode.CANNOT_CONNECT,
                    message: 'Cannot connect, connection triggered incorrectly.',
                });
            }
            var _a = event.data, connector = _a.connector, options = _a.options;
            _this._emitter.emit(EvmNetworkEvent.CONNECTING);
            connectWallet(_this.connectors, connector, options !== null && options !== void 0 ? options : {})
                .then(function (data) { return _this.state.transition({ type: 'CONNECT_SUCCESS', data: data }); })
                .catch(function (error) { return _this.state.transition({ type: 'CONNECT_ERROR', data: error }); });
        };
        this.handleConnected = function (context, event) {
            _this._logger.verbose('Connected', { context: context, event: event });
            // Should only be connected successfully via the CONNECT_SUCCESS event
            if (event.type !== 'CONNECT_SUCCESS') {
                throw new core.MoralisNetworkError({
                    code: core.NetworkErrorCode.CANNOT_CONNECT,
                    message: 'Connected incorrectly.',
                });
            }
            var _a = event.data, connector = _a.connector, provider = _a.provider;
            _this.connector = connector;
            _this._internalProvider = provider;
            _this._updateProvider();
            connector.on(evmConnectorUtils.EvmConnectorEvent.ACCOUNT_CHANGED, _this._handleAccountChange);
            connector.on(evmConnectorUtils.EvmConnectorEvent.CHAIN_CHANGED, _this._handleChainChange);
            _this._emitter.emit(EvmNetworkEvent.CONNECTED, event.data);
        };
        /**
         * Trigger state changes
         */
        this.connect = function (connector, options) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.isConnecting) {
                            throw new core.MoralisNetworkError({
                                code: core.NetworkErrorCode.CANNOT_CONNECT,
                                message: 'Cannot connect, as a connection attempt is already pending.',
                            });
                        }
                        if (!this.isConnected) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.disconnect()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!this.state.can('CONNECT')) {
                            throw new core.MoralisNetworkError({
                                code: core.NetworkErrorCode.CANNOT_CONNECT,
                                message: 'Cannot connect.',
                            });
                        }
                        this.state.transition({
                            type: 'CONNECT',
                            data: {
                                connector: connector,
                                options: options,
                            },
                        });
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                var handleResolve = function (data) {
                                    resolve(data);
                                    _this._emitter.off(EvmNetworkEvent.CONNECTED, handleResolve);
                                    _this._emitter.off(EvmNetworkEvent.CONNECTING_ERROR, handleReject);
                                };
                                var handleReject = function (error) {
                                    reject(error);
                                    _this._emitter.off(EvmNetworkEvent.CONNECTED, handleResolve);
                                    _this._emitter.off(EvmNetworkEvent.CONNECTING_ERROR, handleReject);
                                };
                                _this._emitter.on(EvmNetworkEvent.CONNECTED, handleResolve);
                                _this._emitter.on(EvmNetworkEvent.CONNECTING_ERROR, handleReject);
                            })];
                }
            });
        }); };
        this.disconnect = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.isConnecting) {
                    throw new core.MoralisNetworkError({
                        code: core.NetworkErrorCode.CANNOT_CONNECT,
                        message: 'Cannot disconnect, as a connection attempt is still pending',
                    });
                }
                if (!this.state.can('DISCONNECT')) {
                    throw new core.MoralisNetworkError({
                        code: core.NetworkErrorCode.CANNOT_CONNECT,
                        message: 'Cannot disconnect',
                    });
                }
                this.state.transition({ type: 'DISCONNECT' });
                return [2 /*return*/];
            });
        }); };
        this.cancelRequest = function () { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!this.isConnecting) {
                    throw new core.MoralisNetworkError({
                        code: core.NetworkErrorCode.CANNOT_CANCEL,
                        message: 'Cannot cancel request, as no connection attempt is pending',
                    });
                }
                cancelWalletRequest(this.connector)
                    .then(function () {
                    _this.state.transition({
                        type: 'CONNECT_ERROR',
                        data: new core.MoralisNetworkError({
                            code: core.NetworkErrorCode.CANNOT_CONNECT,
                            message: 'Request cancelled',
                        }),
                    });
                })
                    .catch(function () {
                    throw new core.MoralisNetworkError({
                        code: core.NetworkErrorCode.CANNOT_CANCEL,
                        message: 'Cannot cancel request',
                    });
                });
                return [2 /*return*/];
            });
        }); };
        this.connectors = Connectors.create();
        this._logger = logger;
        this._emitter = emitter;
        this.state.start({
            initial: 'Disconnected',
            states: {
                Disconnected: {
                    entry: this.handleDisconnected,
                    on: {
                        CONNECT: {
                            target: 'Connecting',
                        },
                    },
                },
                Connecting: {
                    entry: this.handleConnecting,
                    on: {
                        CONNECT_SUCCESS: {
                            target: 'Connected',
                        },
                        CONNECT_ERROR: {
                            target: 'Disconnected',
                        },
                    },
                },
                Connected: {
                    entry: this.handleConnected,
                    on: {
                        DISCONNECT: {
                            target: 'Disconnected',
                        },
                    },
                },
            },
        });
    }
    /**
     * Updates the ._provider (and therefore .provider) instance, based on the
     * _internalProvider, that is retreived from a connector, and the provided chain.
     * We need to reset this provider every time a chain chainges, as recommended by ethersJs,
     * for user protection.
     */
    Connection.prototype._updateProvider = function () {
        var _a;
        // No need to update if we have no internalProvider set
        if (!this._internalProvider) {
            this._provider = null;
            return;
        }
        // No need to change provider if we have not chain set
        if (!this.chain) {
            return;
        }
        var newProvider = new ethers.providers.Web3Provider(this._internalProvider, (_a = this.chain) === null || _a === void 0 ? void 0 : _a.decimal);
        this._provider = newProvider;
        this._logger.verbose('Provider updated', { provider: newProvider });
        this._emitter.emit(EvmNetworkEvent.PROVIDER_UPDATED, { provider: this.provider });
    };
    Object.defineProperty(Connection.prototype, "isConnected", {
        /**
         * Utilities
         */
        get: function () {
            return this.state.match('Connected');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "isConnecting", {
        get: function () {
            return this.state.match('Connecting');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "canConnect", {
        get: function () {
            return !this.isConnecting;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "hasProvider", {
        /**
         * Getters
         */
        get: function () {
            return this._provider !== null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "provider", {
        get: function () {
            var _a;
            if (!this._provider) {
                return null;
            }
            return this._provider.getSigner((_a = this.account) === null || _a === void 0 ? void 0 : _a.lowercase);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "chain", {
        get: function () {
            var _a, _b;
            return (_b = (_a = this.connector) === null || _a === void 0 ? void 0 : _a.chain) !== null && _b !== void 0 ? _b : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "account", {
        get: function () {
            var _a, _b;
            return (_b = (_a = this.connector) === null || _a === void 0 ? void 0 : _a.account) !== null && _b !== void 0 ? _b : null;
        },
        enumerable: false,
        configurable: true
    });
    return Connection;
}());

var makeTransferErc1155 = function (_provider, _account, _chain) {
    return function (options) { return __awaiter(void 0, void 0, void 0, function () {
        var provider, fromAddress, chain, contractAddress, toAddress, tokenId, value, data, token, response;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    provider = assertProvider(_provider);
                    fromAddress = assertAddress(_account, 'No account is connected');
                    chain = assertChain(_chain, 'Chain is not set on MoralisEvm. Make sure to be properly connected');
                    if (options.chain) {
                        assertChainEquality(options.chain, chain);
                    }
                    contractAddress = core.EvmAddress.create(options.contractAddress);
                    toAddress = core.EvmAddress.create(options.to);
                    tokenId = options.tokenId;
                    value = ethers.BigNumber.from(options.value);
                    data = (_a = options.data) !== null && _a !== void 0 ? _a : [];
                    token = Erc1155__factory.connect(contractAddress.checksum, provider);
                    return [4 /*yield*/, token.safeTransferFrom(fromAddress.checksum, toAddress.checksum, tokenId, value, data)];
                case 1:
                    response = _b.sent();
                    return [2 /*return*/, wrapEthersTransactionResponse(response, chain)];
            }
        });
    }); };
};

var isContractFunction = function (contractFunction) {
    if (!contractFunction) {
        return false;
    }
    return true;
};
var allInputsMatchTopics = function (inputs, topics) {
    return inputs.every(function (input, index) { return input.type === topics[index]; });
};
var getPossibleTopics = function (functionDataArray) {
    return functionDataArray.map(function (data) { var _a; return "".concat(data.name, "(").concat((_a = data.inputs) === null || _a === void 0 ? void 0 : _a.map(function (input) { return input.type; }).join(','), ")"); });
};
var getOverloadedFunctionData = function (overloadedFunctionMatch, abi) {
    var nameWithoutTopics = overloadedFunctionMatch[1];
    var topics = overloadedFunctionMatch[2]
        .split(',')
        .map(function (topic) { return topic.trim(); })
        .filter(function (topic) { return !!topic; });
    var functionDataArray = abi.filter(function (x) { return x.name === nameWithoutTopics; });
    if (functionDataArray.length === 0) {
        throw new core.MoralisServerError({
            code: core.ServerErrorCode.CONTRACT_EXECUTION_FAILED,
            message: 'Function does not exist in abi',
        });
    }
    var functionData = functionDataArray.find(function (_a) {
        var _b;
        var inputs = _a.inputs;
        if (!inputs) {
            return false;
        }
        var hasSameInputs = ((_b = inputs === null || inputs === void 0 ? void 0 : inputs.length) !== null && _b !== void 0 ? _b : 0) === topics.length;
        if (!hasSameInputs) {
            return false;
        }
        if (!allInputsMatchTopics(inputs, topics)) {
            return false;
        }
        return true;
    });
    if (!functionData) {
        var errorMessage = "Function with the provided topic does not exist in abi. Possible funcationNames: ".concat(getPossibleTopics(functionDataArray).join(' ,'));
        throw new core.MoralisServerError({
            code: core.ServerErrorCode.CONTRACT_EXECUTION_FAILED,
            message: errorMessage,
        });
    }
    return functionData;
};
var getFunctionData = function (functionName, abi) {
    // Check if function is an overloaded function definition. ex "getMessage(string)", or "getMessage()"
    var overloadedFunctionMatch = functionName.match(/^(.+)\((.*)\)$/);
    if (overloadedFunctionMatch) {
        return getOverloadedFunctionData(overloadedFunctionMatch, abi);
    }
    var functionDataArray = abi.filter(function (x) { return x.name === functionName; });
    var hasFunctionData = functionDataArray.length > 0;
    var hasOneFunctionData = functionDataArray.length > 0;
    if (!hasFunctionData) {
        throw new core.MoralisServerError({
            code: core.ServerErrorCode.CONTRACT_EXECUTION_FAILED,
            message: 'Function does not exist in abi',
        });
    }
    if (!hasOneFunctionData) {
        var errorMessage = "Multiple function definitions found in the abi. Please include the topic in the functionName. Possible funcationNames: ".concat(getPossibleTopics(functionDataArray).join(' ,'));
        throw new core.MoralisServerError({
            code: core.ServerErrorCode.CONTRACT_EXECUTION_FAILED,
            message: errorMessage,
        });
    }
    return functionDataArray[0];
};
var assertParams = function (functionData, params) {
    if (params === void 0) { params = {}; }
    var missingParams = [];
    if (!functionData.inputs) {
        return;
    }
    for (var _i = 0, _a = functionData.inputs; _i < _a.length; _i++) {
        var input = _a[_i];
        if (!input.name) {
            continue;
        }
        var value = params[input.name];
        if (value == null) {
            missingParams.push(input.name);
        }
    }
    if (missingParams.length === 0) {
        return;
    }
    throw new core.MoralisServerError({
        code: core.ServerErrorCode.CONTRACT_EXECUTION_FAILED,
        message: "Missing values for required parameters: ".concat(missingParams.join(', ')),
    });
};
var parseParams = function (functionData, params) {
    var _a;
    return ((_a = functionData.inputs) !== null && _a !== void 0 ? _a : []).map(function (input) {
        if (params && input.name && params[input.name]) {
            return params[input.name];
        }
    });
};
var parseOverrides = function (overrides) {
    if (overrides === void 0) { overrides = {}; }
    return (__assign(__assign({}, overrides), { from: overrides.from ? core.EvmAddress.create(overrides.from).checksum : undefined }));
};
// TODO: add generic types to make sure functionName is defined (and possible return gemeric typed result? Can we use typechain as well?)
// TODO: split up in read and write call (and wrap write call in EvmTransactionReceipt)
var makeExecutefunction = function (_provider) {
    return function (options) { return __awaiter(void 0, void 0, void 0, function () {
        var provider, contractAddress, abi, functionName, params, overrides, functionData, contract, contractMethod, parsedParams, parsedOverrides, result;
        return __generator(this, function (_a) {
            provider = assertProvider(_provider);
            contractAddress = core.EvmAddress.create(options.contractAddress);
            abi = options.abi, functionName = options.functionName, params = options.params, overrides = options.overrides;
            functionData = getFunctionData(functionName, abi);
            assertParams(functionData, params);
            contract = new ethers.Contract(contractAddress.checksum, abi).connect(provider);
            contractMethod = contract[functionName];
            if (!isContractFunction(contractMethod)) {
                throw new core.MoralisServerError({
                    code: core.ServerErrorCode.CONTRACT_EXECUTION_FAILED,
                    message: 'Provided functionName does not exist',
                });
            }
            parsedParams = parseParams(functionData, params);
            parsedOverrides = parseOverrides(overrides);
            result = contractMethod.apply(void 0, __spreadArray(__spreadArray([], parsedParams, false), [parsedOverrides], false));
            return [2 /*return*/, result];
        });
    }); };
};

var MoralisEvm = /** @class */ (function (_super) {
    __extends(MoralisEvm, _super);
    function MoralisEvm(core) {
        var _this = _super.call(this, MoralisEvm.moduleName, core) || this;
        _this.connection = new Connection(_this.logger, _this.emitter);
        /**
         * Event listeners
         */
        _this.onConnecting = function (fn) { return _this.listen(EvmNetworkEvent.CONNECTING, fn); };
        _this.onConnected = function (fn) { return _this.listen(EvmNetworkEvent.CONNECTED, fn); };
        _this.onDisconnected = function (fn) { return _this.listen(EvmNetworkEvent.DISCONNECTED, fn); };
        _this.onConnectingError = function (fn) { return _this.listen(EvmNetworkEvent.CONNECTING_ERROR, fn); };
        _this.onAccountChanged = function (fn) { return _this.listen(EvmNetworkEvent.ACCOUNT_CHANGED, fn); };
        _this.onChainChanged = function (fn) { return _this.listen(EvmNetworkEvent.CHAIN_CHANGED, fn); };
        _this.onProviderUpdated = function (fn) { return _this.listen(EvmNetworkEvent.PROVIDER_UPDATED, fn); };
        /**
         * Connection methods
         */
        _this.connect = function (connector, options) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.connection.connect(connector, options)];
            });
        }); };
        _this.disconnect = function () {
            return _this.connection.disconnect();
        };
        _this.cancelRequest = function () {
            return _this.connection.cancelRequest();
        };
        /**
         * Chain Methods
         */
        _this.signMessage = function (message) { return makeSignMessage(_this.provider)(message); };
        _this.sendTransaction = function (data) { return makeSendTransaction(_this.provider, _this.chain)(data); };
        _this.transferNative = function (data) { return makeTransferNative(_this.sendTransaction, _this.chain)(data); };
        _this.transferErc20 = function (data) { return makeTransferErc20(_this.provider, _this.chain)(data); };
        _this.transferErc721 = function (data) { return makeTransferErc721(_this.provider, _this.account, _this.chain)(data); };
        _this.transferErc1155 = function (data) {
            return makeTransferErc1155(_this.provider, _this.account, _this.chain)(data);
        };
        _this.executeFunction = function (data) { return makeExecutefunction(_this.provider)(data); };
        return _this;
    }
    MoralisEvm.create = function (core$1) {
        return new MoralisEvm(core$1 || core.MoralisCoreProvider.getDefault());
    };
    Object.defineProperty(MoralisEvm.prototype, "web3Library", {
        /**
         * General
         */
        get: function () {
            return ethers.ethers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "connectors", {
        /**
         * Connection getters
         */
        /**
         * Get all available connectors
         */
        get: function () {
            return this.connection.connectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "supportedConnectors", {
        /**
         * Get all names of available connectors
         */
        get: function () {
            return this.connection.connectors.names;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "connector", {
        /**
         * Return the connected connector
         */
        get: function () {
            return this.connection.connector;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "provider", {
        get: function () {
            return this.connection.provider;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "hasProvider", {
        get: function () {
            return this.connection.hasProvider;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "chain", {
        get: function () {
            return this.connection.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "account", {
        get: function () {
            return this.connection.account;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "isConnected", {
        get: function () {
            return this.connection.isConnected;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MoralisEvm.prototype, "isConnecting", {
        get: function () {
            return this.connection.isConnecting;
        },
        enumerable: false,
        configurable: true
    });
    MoralisEvm.prototype.setup = function () {
        // Nothing
    };
    MoralisEvm.prototype.start = function () {
        // Nothing
    };
    MoralisEvm.moduleName = 'evm';
    return MoralisEvm;
}(core.NetworkModule));

exports.Erc1155__factory = Erc1155__factory;
exports.Erc20__factory = Erc20__factory;
exports.Erc721__factory = Erc721__factory;
exports.MoralisEvm = MoralisEvm;
exports["default"] = MoralisEvm;
exports.factories = index;
//# sourceMappingURL=index.js.map
